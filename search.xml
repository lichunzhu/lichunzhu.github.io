<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 805: Split Array With Same Average]]></title>
    <url>%2F2019%2F04%2F22%2F2019-4-22-LeetCode-Problem-805%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/split-array-with-same-average/ 题意给定的整数数组 A ，我们要将 A数组 中的每个元素移动到 B数组 或者 C数组中。（B数组和C数组在开始的时候都为空） 返回true ，当且仅当在我们的完成这样的移动后，可使得B数组的平均值和C数组的平均值相等，并且B数组和C数组都不为空。 示例:输入:[1,2,3,4,5,6,7,8]输出: true解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。 注意: A 数组的长度范围为 [1, 30].A[i] 的数据范围为 [0, 10000]. 题目类型动态规划 题目分析没能独立完成的题目，参考了[Leetcode] 805. Split Array With Same Average 解题报告解出。实质上题目是一个有点像DP但其实又不太DP的暴力题。题目有几个可以挖掘的特性： B, C两个序列是等价的，也就是我们只要找出长度不超过n/2的序列就可以了(另一半直接减了得到) 假设最后分为了两个序列 B, C， 假设序列B的长度为k序列C长一些 (1 &lt;= k &lt;= n/2) ，则我们可得到 total_sum / n = B_sum / k = C_sum / (n - k)，则可得到B_sum = total_sum * k / n，由于B_sum一定为整数，因此 total_sum * k % n == 0，一开始我们可以对 total_sum 进行特判，如果 1 &lt;= k &lt;= n/2 的所有 k 都不满足该条件则可以提前返回 false 如果发现确实有符合条件的k，则用数组 dp[i] 保存长度为 i 的所有序列B的可能和，每个 dp[i] 为一个 unordered_set，加入 A 中某个数 num 的时候可以得到 dp[i] = dp[i] join { for each dp[i - 1] + num}，这一步我们可以采用类似背包问题时的方法，长度从大往小枚举就可以保证这次的不会被重复累积进去了(类似背包省掉 n 的那一维空间) 有了各个长度 i 对应的 set 即 dp[i] 以后，我们只需要检查相应长度 i 是否含有元素 total_sum * i / n 即可，一旦发现存在符合条件的 i，返回 true 即可，否则返回 false 时间复杂度$O(N ^ 3 * M)$M为元素的组合数(恶劣情况可达$N ^ 2$) 源代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool splitArraySameAverage(vector&lt;int&gt;&amp; A) &#123; int n = A.size(), m = n / 2; vector&lt;unordered_set&lt;int&gt;&gt;dp(m + 1); int i; dp[0].insert(0); int sum = accumulate(A.begin(), A.end(), 0); bool isPossible = false; for (i = 1; i &lt;= m; i++) &#123; if (sum * i % n == 0) &#123; isPossible = true; break; &#125; &#125; if (!isPossible) return false; for (int num : A) &#123; for (i = m; i &gt; 0; --i) &#123; for (auto t : dp[i - 1]) &#123; dp[i].insert(t + num); &#125; &#125; &#125; for (i = 1; i &lt;= m; i++) &#123; if (sum * i % n == 0 &amp;&amp; dp[i].count(sum * i / n)) return true; &#125; return false; &#125;&#125;; 题外话这道题做完后学会了一些比较有趣的 C++ 赋值法，可能是之前太菜了都没学过： vector 求和可以用 accumulate(A.begin(), A.end(), 0); 最后一位 0 表示偏移量 vector 新建并赋初值可以用 vector&lt;int&gt;A = vector&lt;int&gt;({1,2,3,4,5}); 解决 map 也可以 map&lt;int&gt;S = map&lt;int&gt;({0}); 要想建空的就直接不要填{}就好了]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 446: Arithmetic Slices II - Subsequence]]></title>
    <url>%2F2019%2F04%2F21%2F2019-4-21-LeetCode-Problem-446%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/ 题意如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列: 1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9 以下数列不是等差数列。 1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从 0 开始。该数组子序列将划分为整数序列 (P0, P1, …, Pk)，P 与 Q 是整数且满足 0 ≤ P0 &lt; P1 &lt; … &lt; Pk &lt; N。 如果序列 A[P0]，A[P1]，…，A[Pk-1]，A[Pk] 是等差的，那么数组 A 的子序列 (P0，P1，…，PK) 称为等差序列。值得注意的是，这意味着 k ≥ 2。 函数要返回数组 A 中所有等差子序列的个数。 输入包含 N 个整数。每个整数都在 $-2 ^ {31}$ 和 $2 ^ {31} -1$ 之间，另外 0 ≤ N ≤ 1000。保证输出小于 $2 ^ {31} -1$。 示例： 输入：[2, 4, 6, 8, 10] 输出：7 解释：所有的等差子序列为：[2,4,6][4,6,8][6,8,10][2,4,6,8][4,6,8,10][2,4,6,8,10][2,6,10] 题目类型动态规划 题目分析没能独立完成的题目，参考了[LeetCode] Arithmetic Slices II - Subsequence 算数切片之二 - 子序列解出。dp[i][diff] dp的数组分为两维:第一维表示以第i个数字作为结尾，第二维表示公差为diff，其值表示以i为结尾的公差为diff的等差数列的个数枚举j &lt; i, 置diff = A[i] - A[j]: 考虑等差数列只有i, j两个数的情况, ++dp[i][diff] 在j结尾的公差为diff的各数列后加上一个A[i]构成新数列, 即dp[i][diff] += dp[j][diff] 2中构成的新数列个数必然&gt;2且以A[i]结尾(防止统计重合),正好res += dp[j][diff]; 由于整数数目太大使用unordered_map&lt;int, int&gt;节省时间空间。本题LeetCode上C++不知为何通不过(应该和常数时间有关系)，最后用了几乎一样的Python通过的。 时间复杂度$O(N ^ 2)$ 源代码CPP12345678910111213141516171819202122232425typedef long long ll;class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); int i, j, res = 0; if (n == 0) return 0; vector&lt;unordered_map&lt;int, int&gt; &gt;dp(n); for (i = 1; i &lt; n; i++) &#123; for (j = 0; j &lt; i; j++) &#123; ll delta = (ll)A[i] - A[j]; if (delta &gt; INT_MAX || delta &lt; INT_MIN) continue; int diff = (int)delta; ++dp[i][diff]; if (dp[j].count(diff)) &#123; dp[i][diff] += dp[j][diff]; res += dp[j][diff]; &#125; &#125; &#125; return res; &#125;&#125;; 源代码PythonPython代码来自Ziqiang 123456789101112131415class Solution(object): def numberOfArithmeticSlices(self, A): """ :type A: List[int] :rtype: int """ total = 0 dp = [collections.defaultdict(int) for item in A] for i in xrange(len(A)): for j in xrange(i): dp[i][A[i] - A[j]] += 1 #dp[i][j]表示在index i这个点，间隔为j的序列的数量 if A[i]-A[j] in dp[j]: #j&lt;i dp[i][A[i] - A[j]] += dp[j][A[i]-A[j]] #为什么上面加的那一次不重复？ total += dp[j][A[i]-A[j]] #因为每次update total是根据j，不是根据i，下次才根据i return total]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1000: Minimum Cost to Merge Stones]]></title>
    <url>%2F2019%2F03%2F04%2F2019-3-4-LeetCode-Problem-1000%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/minimum-cost-to-merge-stones/ 题意有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。 每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。 找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。 示例 1： 输入：stones = [3,2,4,1], K = 2输出：20解释：从 [3, 2, 4, 1] 开始。合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。合并 [4, 1]，成本为 5，剩下 [5, 5]。合并 [5, 5]，成本为 10，剩下 [10]。总成本 20，这是可能的最小值。 示例 2： 输入：stones = [3,2,4,1], K = 3输出：-1解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。 示例 3： 输入：stones = [3,5,1,2,6], K = 3输出：25解释：从 [3, 5, 1, 2, 6] 开始。合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。合并 [3, 8, 6]，成本为 17，剩下 [17]。总成本 25，这是可能的最小值。 提示： 1 &lt;= stones.length &lt;= 30 2 &lt;= K &lt;= 30 1 &lt;= stones[i] &lt;= 100 题目类型动态规划 题目分析dp数组有l,r,k三维，表示l~r的石子合成k堆所需的最小代价初始条件:$ f[l][l][1] = 0,l = 0, 1, 2, … , n - 1 $ 其余取 INF最终答案:$f[0][n - 1][1]$转移方程:$f[l][r][k] = min(f[l][r][k], f[l][m][1] + f[m + 1][r][k - 1]),m = l, l + K - 1, l + 2 * K - 2…$$f[l][r][1] = f[l][r][K] + sum(stones[l] … stones[r])$(P.S.此处的K是题目中的大K)具体看代码实现，一看就懂 时间复杂度$O(N ^ {2} \ast K)$ 源代码1234567891011121314151617181920212223242526272829303132333435const int INF = 1e9;class Solution &#123;private: vector&lt;int&gt;S;public: int get_sum(int l, int r) &#123; if (l &gt; r) return 0; return S[r + 1] - S[l]; &#125; int mergeStones(vector&lt;int&gt;&amp; stones, int K) &#123; int n = stones.size(); int i, l, k, r, m; if ((n - 1) % (K - 1) != 0) return -1; S.clear(); S.push_back(0); for (i = 0; i &lt; n; i++) S.push_back(S[S.size() - 1] + stones[i]); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(K + 1, INF))); for (l = 0; l &lt; n; l++) f[l][l][1] = 0; for (i = 2; i &lt;= n; i++) &#123; for (l = 0; l + i - 1 &lt; n; l++) &#123; r = l + i - 1; for (k = 2; k &lt;= K; k++) &#123; for (m = l; m &lt; r; m += K - 1) f[l][r][k] = min(f[l][r][k], f[l][m][1] + f[m + 1][r][k - 1]); &#125; f[l][r][1] = f[l][r][K] + get_sum(l, r); &#125; &#125; return f[0][n - 1][1]; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 172: Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F02%2F25%2F2019-2-25-LeetCode-Problem-172%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/factorial-trailing-zeroes/ 题意给定一个整数 ** n *，返回 * n! ** 结果尾数中零的数量。 示例 1: 输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 题目类型数学 题目分析以前对这道题一直有误解，今天才发现标解做个记号留存一下。n!的末置0都是由2*5来的，所以只要统计1n的数中含因子5的个数就够了，因为2明显比5多得多。统计的方法也很巧妙，1n中含因子5的个数就是n/5，因为有含2个3个因子5的情况，所以答案为$n/5 + n / 5 ^ 2 + n / 5 ^ 3$… 时间复杂度$O(log _{2} n)$ 源代码123456class Solution &#123;public: int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 992: Subarrays with K Different Integers]]></title>
    <url>%2F2019%2F02%2F18%2F2019-2-18-LeetCode-Problem-992%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/subarrays-with-k-different-integers/ 题意给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。 （例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。） 返回 A 中好子数组的数目。 示例1: 输出：A = [1,2,1,2,3], K = 2输入：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. 示例2: 输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]. 提示: 1.1 &lt;= A.length &lt;= 200002.1 &lt;= A[i] &lt;= A.length3.1 &lt;= K &lt;= A.length 题目类型滑窗 题目分析最开始看到这个题目，很自然而然的想到对每个右端点，要找到构成个数刚好为k的最右边的左端点以及刚好为k+1的最右边的左端点，这两者构成的区间长度总和即为我们最后要求的答案。我最开始的想法是用一个滑窗，用一个map维持滑窗中的整数种类与数目，用堆来维持每种整数最右边的元素位置，堆里的最大值和当前滑窗左端点的区间即为上文所提到的区间。后面看了题解才发现自己还是太naive了，搞两个滑窗一个维护数目是k的一个维护数目是k+1的就行了。代码1是用的堆和map，代码2是写了类的两个滑窗的解法。 时间复杂度$O(N)$ 源代码1123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;private: map&lt;int, int&gt;mp; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt;q;public: int subarraysWithKDistinct(vector&lt;int&gt;&amp; A, int K) &#123; int i, l = 0; int ans = 0; mp.clear(); while (!q.empty()) q.pop(); for (i = 0; i &lt; A.size(); i++) &#123; auto it = mp.find(A[i]); if (it == mp.end()) &#123; if (mp.size() == K) &#123; // add answer while(!q.empty()) &#123; auto t = q.top(); q.pop(); if (mp.find(t.second) != mp.end() &amp;&amp; mp[t.second] == t.first) &#123; mp.erase(t.second); l = t.first + 1; break; &#125; &#125; &#125; mp[A[i]] = i; &#125; else it -&gt; second = i; q.push(make_pair(i, A[i])); if (mp.size() == K) &#123; while(!q.empty()) &#123; auto t = q.top(); q.pop(); if (mp.find(t.second) != mp.end() &amp;&amp; mp[t.second] == t.first) &#123; q.push(t); ans += t.first - l + 1; break; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; 源代码21234567891011121314151617181920212223242526272829303132333435363738394041class Window &#123;private: int count[20002]; int sz;public: Window() &#123; memset(count, 0, sizeof(count)); sz = 0; &#125; int get_size() &#123; return sz; &#125; void add(int x) &#123; if (count[x] == 0) sz++; count[x]++; &#125; void minus(int x) &#123; if (count[x] == 1) sz--; count[x]--; &#125;&#125;;class Solution &#123;public: int subarraysWithKDistinct(vector&lt;int&gt;&amp; A, int K) &#123; int left1 = 0, left2 = 0; int ans = 0; Window window1, window2; for (auto x : A) &#123; window1.add(x); window2.add(x); while (window1.get_size() &gt; K) window1.minus(A[left1++]); while (window2.get_size() &gt;= K) window2.minus(A[left2++]); ans += left2 - left1; &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>滑窗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 218: The Skyline Problem]]></title>
    <url>%2F2019%2F01%2F29%2F2019-1-29-LeetCode-Problem-218%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/the-skyline-problem/ 题意城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线（图B）。 每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。 例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。 输出是以 [ [x1,y1], [x2, y2], [x3, y3], … ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。 例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。 题目类型几何 题目分析看了Eason Liu 的技术博客以后才明白的。 观察样例可以发现轮廓点产生在当前的最高的矩形高度发生变化时，维护动态最高的矩形高度需要使用堆来进行。其次当矩形右端点出现时，需要将堆栈中对应的左端点移出堆，这里可以使用一个map做记录打懒标记的方式保证堆顶的最高高度仍是右端点没有出现的，堆顶懒标记不为0则一直退。 将左右端点都加入排序后，依次扫描每个端点，统计查看高度变化记录轮廓点。这里还有非常重要的一点是排序方法： x不同时按x大小排 x相同，类型不同时左端点排在前面 类型相同时，左端点按高度从大往小排，右端点按高度从小往大排 提一下第3点，左端点从大往小是显然的，不然x相同时可能莫名扫出多个轮廓点，右端点从小往大是可以把小点先打标记不退出，一样是避免错误统计。具体可以推两个例子就明白了。由此可以写出源代码1。 随后可以发现代码可以简化，懒标记是由于priority_queue并没有删除功能，因此可以用mutliset直接删，排序的时候只要将左节点的高度取负就可以完全实现和上文相同的排序效果，直接用pair默认排序就完了，代码可以得到极大简化，由此得到源代码2。 时间复杂度$O(N * log _{2} N)$ 源代码112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define LEFT 0#define RIGHT 1struct node &#123; int x, y; int type; node(int _x, int _y, int _type): x(_x), y(_y), type(_type) &#123;&#125;&#125;;bool cmp(node a, node b) &#123; if (a.x != b.x) return a.x &lt; b.x; if (a.type == LEFT &amp;&amp; b.type == LEFT) return a.y &gt; b.y; if (a.type == RIGHT &amp;&amp; b.type == RIGHT) return a.y &lt; b.y; return a.type == LEFT;&#125;class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;node&gt;lines; for (auto &amp;building : buildings) &#123; lines.emplace_back(building[0], building[2], LEFT); lines.emplace_back(building[1], building[2], RIGHT); &#125; sort(lines.begin(), lines.end(), cmp); priority_queue&lt;int&gt;heap; unordered_map&lt;int, int&gt;mp; int pre = 0, cur = 0; heap.push(0); vector&lt;pair&lt;int, int&gt; &gt;ans; for (auto &amp;line: lines) &#123; if (line.type == LEFT) &#123; heap.push(line.y); &#125; else &#123; ++mp[line.y]; while (!heap.empty() &amp;&amp; mp[heap.top()] &gt; 0) &#123; --mp[heap.top()]; heap.pop(); &#125; &#125; cur = heap.top(); if (cur != pre) &#123; ans.emplace_back(line.x, cur); pre = cur; &#125; &#125; return ans; &#125;&#125;; 源代码212345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt; &gt;lines; for (auto &amp;building : buildings) &#123; lines.emplace_back(building[0], -building[2]); lines.emplace_back(building[1], building[2]); &#125; sort(lines.begin(), lines.end()); multiset&lt;int&gt;heap; int pre = 0, cur = 0; heap.insert(0); vector&lt;pair&lt;int, int&gt; &gt;ans; for (auto &amp;line: lines) &#123; if (line.second &lt; 0) &#123; heap.insert(-line.second); &#125; else &#123; heap.erase(heap.find(line.second)); // 只删一个 &#125; cur = *heap.rbegin(); if (cur != pre) &#123; ans.emplace_back(line.first, cur); pre = cur; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 719: Find K-th Smallest Pair Distance]]></title>
    <url>%2F2019%2F01%2F19%2F2019-1-19-LeetCode-Problem-719%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/find-k-th-smallest-pair-distance/ 题意给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。 示例 1: 输入：nums = [1,3,1]k = 1输出：0 解释：所有数对如下：(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。 提示: 2 &lt;= len(nums) &lt;= 10000. 0 &lt;= nums[i] &lt; 1000000. 1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. 题目类型二分 题目分析对于该类题目，发现k很大的时候，基本也就和二分脱不开干系了。 我们可以注意到，将数组排序后，求出 距离 &lt;= k 的数对个数是非常简单的。 最开始的想法是扫一遍数组，对每个数字加上 k 后加个二分就可以了，二分的时候下一个数字可以直接以上一个数组满足的最大位置作为二分下界再往后分，可以节约很多时间。 由此，我们可以二分最小距离的大小，直至求出答案，具体就见代码了。 对代码需要说明的一点是，二分求出的是满足 &lt;= k 的最大设定距离，因此我们将k - 1， l + 1就能得到正好的第k个最小距离。 时间复杂度$O(log _{2} (\max(num)-\min(num)) \ast N \ast log _{2} N)$ 源代码1234567891011121314151617181920212223class Solution &#123;public: int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) &#123; int i, n = nums.size(), t; sort(nums.begin(), nums.end()); int m = nums[n - 1] - nums[0]; int l = -1, r = m + 1, mid, tmp; k--; while (l &lt; r - 1) &#123; mid = (l + r) &gt;&gt; 1; tmp = 0; for (i = 0; i &lt; n - 1; i++) &#123; t = upper_bound(nums.begin(), nums.end(), nums[i] + mid) - nums.begin() - i - 1; tmp += t; &#125; if (tmp &lt;= k) l = mid; else r = mid; &#125; return l + 1; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 903: Valid Permutations for DI Sequence]]></title>
    <url>%2F2019%2F01%2F02%2F2019-1-2-LeetCode-Problem-903%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/valid-permutations-for-di-sequence/ 题意我们给出 S，一个源于 {‘D’, ‘I’} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）有效排列 是对整数 {0, 1, …, n} 的一个排列 P[0], P[1], …, P[n]，使得对所有的 i： 如果 S[i] == ‘D’，那么 P[i] &gt; P[i+1]，以及； 如果 S[i] == ‘I’，那么 P[i] &lt; P[i+1]。 有多少个有效排列？因为答案可能很大，所以请返回你的答案模 10^9 + 7. 题目类型动态规划 题目分析又一道动态规划题，涉及到对这种特殊序列的理解。 将求方案的问题拆解一下，求i长度的序列由求i-1长度的序列转换而来。 设f[i][j]为序列{0,1,…,i}以j作为结尾的排列总数。 当前字母为’D’时，显然i-1位上只能够取j+1,j+2,…i-1.但是这样可能会有重复的情况(前面的序列也有j)，这种情况我们只需要把序列中大于等于j的数全部加1，则能既满足原有性质又不产生重复(这一点拿几个例子推一下就可以了)。这样j也是可以转移的，因此有$ f[i][j] = f[i-1][j] + f[i-1][j+2] + … + f[i-1][i-1] $ 当前字母为’I’时，显然i-1位上只能够取0,1,…j-1.这时仍然会有重复情况，像上文一样解决即可。同时，f[i][0]必定为0，做一下特判即可，可以得到$ f[i][j] = f[i-1][0] + f[i-1][j+2] + … + f[i-1][j-1] $ 连续求和很容易用部分和技术搞定，因此复杂度只有$N^{2}$. 关于全部加1举个例子，假如前面的序列是{0,2,3,4,1}，此时我们在后面加入3，把大于等于的部分加1，新序列为{0,2,4,5,1,3}，数列大小关系不会发生改变。 时间复杂度$O(N ^ {2})$ 源代码123456789101112131415161718192021222324class Solution &#123;public: int numPermsDISequence(string S) &#123; const int Mod = 1000000007; int i, j, n = S.size(); int f[202][202], sf[202][202]; memset(f, 0, sizeof(f)); memset(sf, 0, sizeof(sf)); f[0][0] = sf[0][0] = 1; for (i = 1; i &lt;= n; i++) &#123; for (j = 0; j &lt;= i; j++) &#123; if (S[i - 1] == 'I') &#123; if (j == 0) continue; f[i][j] = sf[i - 1][j - 1]; &#125; else f[i][j] = (sf[i - 1][i - 1] - (j &gt; 0 ? sf[i - 1][j - 1]: 0) + Mod) % Mod; sf[i][j] = ((j &gt; 0 ? sf[i][j - 1]: 0) + f[i][j]) % Mod; &#125; &#125; return sf[n][n]; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word，endnote使用小结]]></title>
    <url>%2F2018%2F12%2F25%2F2018-12-25-research-word-skills%2F</url>
    <content type="text"><![CDATA[Word引用中的题注和交叉引用1.公式编号问题，公式编号右对齐内容居中问题 使用表格法，参考苏宙行的知乎回答在word里加入一个模板公式 使用制表符，参考这篇百度经验文章就可以解决，不过感觉表格更好 需要注意的是，使用表格法插入的公式只有用Word自带的公式才会在公式比较高时显得美观 2.上一个问题的后续，引用公式时加上超链接，以及图片表格的超链接问题 通通都可以使用题注和交叉引用模块完成。只需注意区分设置好题注中的标签类型与字符，同时交叉引用时设置一下引用内容就可以了 3.中间删掉了几个公式需要更新编号 全选需要更改部分，F9即可(更新域) Endnote处理文献引用参考可乐的知乎专栏就差不多了，需要引用文献时直接拖过去就可以，非常简单。 注意在最后交稿的时候要把文章最后段的endnote文献集转成普通文本，否则有的电脑可能无法识别。前面的编号部分不管似乎也没什么关系。 MathType处理公式编号与右对齐1.在Word中的MathType栏单击右编号即可插入编号右对齐，编号是自动递增的。 2.如果不需要插入右对齐的编号，直接点击MathType栏的插入编号，编号仍然是递增的。 3.需要类似于Word的交叉引用的操作时，在MathType栏中点击插入引用，然后再双击要插入的公式的编号，即可插入引用。但是和交叉引用不一样的是这个引用不是超链接，要跳转到公式的话需要双击而不是Ctrl+左键。 PS：如果因为域代码问题引发公式显示乱码，全选文档Alt+F9基本可以修复，如果不行还是Google吧:P IEEE格式问题从IEEE官网下载了citations后发现这个RIS导入endnote后没有月份，但其实IEEE把月份放在了Y1栏里，于是写了份python代码,把Y1栏下面的除月份的字母和’.’以外的东西都忽略掉，同时在控制台输出做一次double check后用新的RIS导进去期刊的月份就是正常的啦！]]></content>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 913: Cat and Mouse]]></title>
    <url>%2F2018%2F12%2F24%2F2018-12-24-LeetCode-problem-913%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/cat-and-mouse/ 题意两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。 该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。 老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。 在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。 此外，猫无法移动到洞（结点 0）里。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠占据相同的结点，猫获胜。 如果老鼠躲入洞里，老鼠获胜。 如果某一位置重复出现（即，玩家们的位置和移动顺序都与上一个回合相同），游戏平局。 给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。 题目类型博弈 图论 题目分析大概是遇到的最难的LeetCode的题了。看了张慕辉的题解后照搬着写了一遍才感觉有点理解。 首先定义color[mPos][cPos][turn]表示老鼠走到mPos，猫走到cPos时候的必胜状态，1表示老鼠赢，2表示猫赢(turn也是同样数字定义) 注意到其中有一些点的胜负状态是确定的，规则如下： 当mPos = 0，老鼠胜 当mPos = cPos，猫胜 因此我们可以由这些确定的状态出发，往前反推，去推理其他状态下的博弈情况。把所有已经确定状态还没有反推的点压入队列。回推时一旦确定一个状态的color就压入队列继续反推，思想有点类似于拓扑排序。 反推的时候，因为猫鼠都是最佳状态，说明绝对不会主动走进败局，且有胜利机会则必走。 因此，当上一步轮到MOUSE走，当前的color是MOUSE时可以直接染色上一步的状态。 当前的color是CAT时，老鼠除非是走投无路一定不会走过来，因此记录一下上一状态的出度，遇见一次就出度减一，当出度为零时说明所有该状态的下招都是猫胜，上一状态也只能是猫胜了，记录为猫胜压入队列。 如果有状态到最后都没被染色，说明这个状态是平局，因为没有被必败也没有必胜，因此只有平了。这个特性推几个例子可以有一些理解。 时间复杂度$O(N ^ {3})$ 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct node &#123; int cPos, mPos; int turn; node (int m, int c, int t): cPos(c), mPos(m), turn(t) &#123;&#125;&#125;;class Solution &#123;public: int catMouseGame(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n = graph.size(); const int MOUSE = 1, CAT = 2; int i, j; int color[202][202][3]; int outDegree[202][202][3]; queue&lt;node&gt;q; memset(color, 0, sizeof(color)); memset(outDegree, 0, sizeof(outDegree)); for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; n; j++) &#123; if (j == 0) continue; if (i == 0) &#123; color[i][j][CAT] = color[i][j][MOUSE] = MOUSE; q.emplace(i, j, MOUSE); q.emplace(i, j, CAT); continue; &#125; if (i == j) &#123; color[i][j][CAT] = color[i][j][MOUSE] = CAT; q.emplace(i, j, MOUSE); q.emplace(i, j, CAT); continue; &#125; outDegree[i][j][MOUSE] = graph[i].size(); for (int x: graph[j]) if (x) outDegree[i][j][CAT]++; &#125; &#125; while (!q.empty()) &#123; node cur = q.front(); q.pop(); int mPos = cur.mPos, cPos = cur.cPos, turn = cur.turn; if (color[mPos][cPos][turn] == 0) continue; if (turn == MOUSE) &#123; for (int x: graph[cPos]) &#123; if (x == 0 || color[mPos][x][CAT]) continue; if (color[mPos][cPos][turn] == CAT) &#123; color[mPos][x][CAT] = CAT; q.emplace(mPos, x, CAT); &#125; else &#123; outDegree[mPos][x][CAT]--; if (outDegree[mPos][x][CAT] == 0) &#123; color[mPos][x][CAT] = MOUSE; q.emplace(mPos, x, CAT); &#125; &#125; &#125; &#125; else &#123; for (int x: graph[mPos]) &#123; if (color[x][cPos][MOUSE]) continue; if (color[mPos][cPos][turn] == MOUSE) &#123; color[x][cPos][MOUSE] = MOUSE; q.emplace(x, cPos, MOUSE); &#125; else &#123; outDegree[x][cPos][MOUSE]--; if (outDegree[x][cPos][MOUSE] == 0) &#123; color[x][cPos][MOUSE] = CAT; q.emplace(x, cPos, MOUSE); &#125; &#125; &#125; &#125; &#125; return color[1][2][MOUSE]; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 964: Least Operators to Express Number]]></title>
    <url>%2F2018%2F12%2F23%2F2018-12-23-LeetCode-problem-964%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/least-operators-to-express-number/ 题意给定一个正整数 x，我们将会写出一个形如 x (op1) x (op2) x (op3) x … 的表达式，其中每个运算符 op1，op2，… 可以是加、减、乘、除（+，-，*，或是 /）之一。例如，对于 x = 3，我们可以写出表达式 3 * 3 / 3 + 3 - 3，该式的值为 3 。 在写这样的表达式时，我们需要遵守下面的惯例： 除运算符（/）返回有理数。 任何地方都没有括号。 我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。 不允许使用一元否定运算符（-）。例如，“x - x” 是一个有效的表达式，因为它只使用减法，但是 “-x + x” 不是，因为它使用了否定运算符。 我们希望编写一个能使表达式等于给定的目标值 target 且运算符最少的表达式。返回所用运算符的最少数量。 题目类型动态规划 题目分析一道有点像数位DP的动态规划题，但是总体来说强度还行。 因为操作的正整数只有一个，所以拿到该题的第一反应就是把target按求x进制的方式拆分为多个x的幂之和。 首先来设想假设没有减号(-)的情况，不难发现如果不是为了得到1使用除号都只能增加运算符却对结果没有帮助。同时，表达式中一定有一个正数。把target按x的幂级数分解后，需要的运算符数就是 (达到该幂级数所需运算符数)*(该位上的数字) 之和。 举个例子:x = 3, target = 19按位分解后得到 [1, 0, 2] (从低到高), $19=1+0 \ast 3+2 \ast 3^{2}$需要的运算符数为 2 + 2 * 2 - 1 = 5即为 + 3 / 3 + 3 * 3 + 3 * 3，去掉最首的’+’号答案-1 接下来考虑表达式中存在减号(-)的情况。存在减号时，假设某位的数字为t，得到数字t可以有两种方式： 加上t个该级数的数字 由高位减去该级数的数字，减去的个数为(x-t)个 定义f数组值为需要的最小运算符数，a[i]为i位上的数字，bit(i)为得到i位的幂级数所需的运算符数字(含开头的符号)，f[i][0]为在第i位使用第一种方式，f[i][1]为第二种方式，不难推出转移方程为：$f[i][0]=min(f[i - 1][0], f[i - 1][1]) + bit(i) \ast a[i]$$\begin{split}f[i][1]=&amp;min(f[i - 1][0] + (x - a[i]) * bit(i) + bit(i + 1), f[i - 1][1] + \\ &amp;(x - a[i] - 1) \ast bit(i) + bit(i + 1) - bit(i)) \end{split}$ f[i][0]的转移方程不难理解，主要说一下f[i][1]: 假设低位是没被减的，那么该位就是 高位 - 低位 的运算符之和。 假设低位是被减的，那么该位转移时要将低位所使用的被减数换成高一位的被减数，也即是bit(i + 1) - bit(i)部分。 同时因为低位已经减掉了一部分，所以这一位是从x-1开始的，也即是(x - a[i] - 1)的来历。 时间复杂度$O(N ^ {3})$ 源代码1234567891011121314151617181920212223242526272829class Solution &#123;public: int get_bit(int i) &#123; i--; if (i == 0) return 2; return i; &#125; int leastOpsExpressTarget(int x, int target) &#123; int t = target; vector&lt;int&gt;a, b; while (t &gt; 0) &#123; b.push_back(t % x); t /= x; &#125; a.push_back(0); for (int i : b) a.push_back(i); int f[30][2]; memset(f, 0, sizeof(f)); for (int i = 1; i &lt; a.size(); i++) &#123; f[i][0] = min(f[i - 1][0], f[i - 1][1]) + get_bit(i) * a[i]; f[i][1] = f[i - 1][0] + (x - a[i]) * get_bit(i) + get_bit(i + 1); if (i &gt; 1) f[i][1] = min(f[i][1], f[i - 1][1] + (x - a[i] - 1) * get_bit(i) + get_bit(i + 1) - get_bit(i)); &#125; return min(f[a.size() - 1][1], f[a.size() - 1][0]) - 1; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 920: Number of Music Playlists]]></title>
    <url>%2F2018%2F12%2F17%2F2018-12-17-LeetCode-problem-920%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/number-of-music-playlists/ 题意你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表： 每首歌至少播放一次。 一首歌只有在其他 K 首歌播放完之后才能再次播放。 返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。 其中: 0 &lt;= K &lt; N &lt;= L &lt;= 100 题目类型动态规划 题目分析动态规划题目，使用f(n,l)表示剩余听n种歌，l个位置，最小间隔为k时的听歌方案。 转移方程分为两种: 该位置放的歌前面都没有出现过，则n种歌随便选一种，该种歌前面都不能再选，转移自f(n-1,l-1) 该位置放的歌前面已经出现过，则最近的k个位置的歌不能再选，只能选(n-k)种，该种歌前面还可以选，转移自f(n,l-1) 有f(n,l) = f(n-1,l-1)*n + f(n,l-1)*(n-k) 边界条件: n &gt; l 时 l 个位置放不完 n 种歌，为0 n &lt; k + 1 时 不能保证 k 个位置内不出现同种类的歌曲，为0 n == l 时 答案为 n 的全排列，不再多言； n == k + 1 时 答案也是 n 的排列，相当于第一首歌和最后一首歌一定一样其他歌全排列 时间复杂度$O(N \ast L \ast K)$ 源代码12345678910111213141516171819202122232425typedef long long LL;int f[102][102][102];int A[102];class Solution &#123;public: const int Mod = 1000000007; Solution() &#123; memset(f, -1, sizeof(f)); A[0] = 1; for(int i = 1; i &lt;= 100; i++) A[i] = (LL)A[i - 1] * i % Mod; &#125; int numMusicPlaylists(int N, int L, int K) &#123; if (N == L || N == K + 1) return A[N]; if (N &gt; L || N &lt; K + 1) return 0; if (f[N][L][K] != -1) return f[N][L][K]; int ans = (LL)numMusicPlaylists(N - 1, L - 1, K) * N % Mod; ans += (LL)numMusicPlaylists(N, L - 1, K) * (N - K) % Mod; ans %= Mod; return f[N][L][K] = ans; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 115]]></title>
    <url>%2F2018%2F12%2F16%2F2018-12-16-LeetCode-contest-115%2F</url>
    <content type="text"><![CDATA[Prison Cells After N Days题目链接https://leetcode.com/problems/prison-cells-after-n-days/ 题意给一个仅包含0和1的长度为8的数组(排成一行)，数组进行一次变换的定义如下: 如果一个元素相邻的元素都为1或都为0，这个元素下一步会变成1 否则，元素变成0 (最首元素和最末元素始终没有两个相邻元素所以会变成0) 求出数组经过$N(1 \leq N \leq 10^{9})$次变换后的值 题目类型智力 题目分析咋一看N很大有点吓人，但细细一想数组总的可能情况也只有 $ 2^{8} = 256 $种，而且数组是满足循环性质的，所以数组一定会跑不到N次就出现循环，问题就变得简单了。 利用二进制记录数组状态，一旦数组重复了以前出现的样子，就不必再计算，把 剩下的步数 除以 循环的长度 取模值，继续步进该数值的步数即是循环N次后的答案。 时间复杂度$O(256*8)$ 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int toInt(vector&lt;int&gt; a) &#123; int i, x = 0; for (i = 0; i &lt; 8; i++) x = ((x &lt;&lt; 1) + a[i]); return x; &#125; vector&lt;int&gt; change(vector&lt;int&gt; a) &#123; int i; vector&lt;int&gt; b; b.push_back(0); for (i = 1; i &lt; 7; i++) &#123; if (a[i + 1] == a[i - 1]) b.push_back(1); else b.push_back(0); &#125; b.push_back(0); return b; &#125; vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;&amp; cells, int N) &#123; int i, tmp; vector&lt;vector&lt;int&gt;&gt; save_cells; save_cells.push_back(cells); map&lt;int, int&gt; S; S[toInt(cells)] = 0; for (i = 1; i &lt;= N; i++) &#123; cells = change(cells); tmp = toInt(cells); if (S.find(tmp) != S.end()) break; S[tmp] = i; save_cells.push_back(cells); &#125; if (i == N + 1) return cells; int j = S[tmp]; N = (N - j) % (i - j) + j; return save_cells[N]; &#125;&#125;; Check Completeness of a Binary Tree题目链接https://leetcode.com/problems/check-completeness-of-a-binary-tree/ 题意给出一棵树判断其是否属于完全二叉树得到true or false，关于完全二叉树的定义: complete binary tree 完全二叉树中除最后一层外均有节点填满，且最后一层的节点全部靠左(还是看wiki吧不知道怎么说) 树的节点数在1到100间 题目类型树 题目分析我的办法是首先找到每个节点的深度得到最大深度maxdep，然后统计深度少于maxdep的节点数，要满足等于$2^{maxdep - 1} - 1$ 随后把倒数第二层的所有节点的左右儿子(包括NULL)都放入一个数组，判断数组是否是 左边全是not NULL，右边全是NULL，换句话说如果第一次出现NULL了以后如果后面还有not NULL的节点则不是完全二叉树 应该有比我更好的办法 时间复杂度$O(N)$ 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: map&lt;TreeNode*, int&gt;S; int maxdep = -1; void Dfs(TreeNode *cur, int dep) &#123; if (cur == NULL) return; maxdep = max(maxdep, dep); S[cur] = dep; Dfs(cur-&gt;left, dep + 1); Dfs(cur-&gt;right,dep + 1); &#125; bool isCompleteTree(TreeNode* root) &#123; queue&lt;TreeNode*&gt;q; TreeNode* cur; Dfs(root, 1); q.push(root); int cnt = 0; bool flag = true; vector&lt;TreeNode*&gt;a; while(!q.empty()) &#123; cur = q.front();q.pop(); cnt++; if (flag) &#123; if (S[cur] == maxdep) &#123; flag = false; if (cnt != (1 &lt;&lt; (maxdep - 1))) return false; &#125; &#125; if (!flag) a.push_back(cur); if (cur) &#123; if (S[cur] &lt; maxdep - 1) &#123; if (!(cur-&gt;left &amp;&amp; cur-&gt;right)) return false; &#125; q.push(cur-&gt;left); q.push(cur-&gt;right); &#125; &#125; flag = true; for (int i = 0; i &lt; a.size(); i++) &#123; if (!a[i]) &#123; flag = false; &#125; if (!flag &amp;&amp; a[i]) return false; &#125; return true; &#125;&#125;; Regions Cut By Slashes题目链接https://leetcode.com/problems/regions-cut-by-slashes/ 题意由 1 x 1 的方格中组成 N x N 的网格grid，每个 1 x 1 的网格中包含 /,\或空格，这些字符会将方格划分成一些区域。 给出每个网格中的字符，求出划分出的区域的个数。（请注意，反斜杠字符是转义的，因此 \ 用 “\“ 表示） grid 满足 1 &lt;= grid.length == grid[0].length &lt;= 30 具体含义戳链接看一下样例应该能明白得更透彻 题目类型图论并查集 题目分析很好玩的题目，咋一看很让人摸不着头脑，但是细细一想这道题可以转换成图论中求联通块的数目的问题。 把每个 1 x 1 的小方格分为 左边 和 右边 两个，每次连边时只考虑相邻块的左边的块和上面的块： 连接上面的块时，首先看自己网格，如果是’/‘用左块去连，如果是’&#39;用右块去连;其次看上面网格，是’&#39;则连左边块，是’/‘则连右边块 连接左边的块时，不管左边块是什么，一定是本块的左边块 连 左边网格的右块 方格为’ ‘, 把该网格的左块和右块连起来 连边找联通块数目，并查集解决这个问题非常方便，就不多赘述了 时间复杂度$O(grid.length ^ {2})$ 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123;public: int fa[10020], n; int get_fa(int x) &#123; if (fa[x] != 0) return fa[x] = get_fa(fa[x]); return x; &#125; void Combine(int x, int y) &#123; x = get_fa(x); y = get_fa(y); if (x == y) return; if (x &gt; y) swap(x, y); fa[y] = x; &#125; int get_sit(int x, int y) &#123; x++; y++; return (x - 1) * n + y; &#125; int regionsBySlashes(vector&lt;string&gt;&amp; grid) &#123; int m, sit, sl, sr; int upsit,leftsit; int i, j, maxsit = 0; n = grid.size(); for (i = 0; i &lt; n; i++) &#123; m = grid[i].size(); for (j = 0; j &lt; m; j++) &#123; sit = get_sit(i, j); upsit = get_sit(i - 1, j); leftsit = get_sit(i, j - 1); sl = 2*sit - 1; sr = 2*sit; maxsit = max(maxsit, sit); if (grid[i][j] == ' ') &#123; Combine(sl, sr); &#125; if (grid[i][j] == '/') &#123; if (i &gt; 0) &#123; if (grid[i - 1][j] == '/') Combine(upsit * 2, sl); else Combine(upsit * 2 - 1, sl); &#125; if (j &gt; 0) &#123; Combine(leftsit * 2, sl); &#125; &#125; else &#123; if (i &gt; 0) &#123; if (grid[i - 1][j] == '/') Combine(upsit * 2, sr); else Combine(upsit * 2 - 1, sr); &#125; if (j &gt; 0) &#123; Combine(leftsit * 2, sl); &#125; &#125; &#125; &#125; int ans = 0; for (i = 1; i &lt;= maxsit*2; i++) if (fa[i] == 0) ans++; return ans; &#125;&#125;; Delete Columns to Make Sorted III题目链接https://leetcode.com/problems/delete-columns-to-make-sorted-iii/ 题意给出一个由N个相同长度的小写字符串组成的数组A，可以选择其中的某列，把所有字符串的该列的字符都删掉。 例如 A = [“babca”,”bbazb”] 删除集合为 {0, 1, 4}， 最后会剩下 [“bc”,”az”] 求出最小的集合，满足删除后的数组A中的每个字符串都有字典序不降序 (ie. A[0][0] &lt;= A[0][1] &lt;= … &lt;= A[0][A[0].length - 1]) 其中： 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 题目类型动态规划 题目分析就是披了层皮的最长上升子序列问题，定义第i列小于等于第j列为: 所有A中的字符串都有 A[k][i] &lt;= A[k][j] 如果满足该条件则有转移方程 f[j] = max { f[i] + 1 } f[i]的初值为1，求出A中的最长上升子序列长度后 列数 - 长度 即为最终的答案 时间复杂度$O(A.length \ast {A[i].length ^ {2}})$ 源代码12345678910111213141516171819202122232425class Solution &#123;public: bool smaller(int i, int j, vector&lt;string&gt;&amp; A, int n) &#123; int k; for (k = 0; k &lt; n; k++) if (A[k][i] &gt; A[k][j]) return false; return true; &#125; int minDeletionSize(vector&lt;string&gt;&amp; A) &#123; int n = A.size(), m = A[0].size(); int i, maxd = -1, j; int f[102]; for (i = 0; i &lt; m; i++) &#123; f[i] = 1; for (j = 0; j &lt; i; j++) &#123; if (smaller(j, i, A, n)) f[i] = max(f[i], f[j] + 1); &#125; maxd = max(maxd, f[i]); &#125; return m - maxd; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>智力</tag>
        <tag>树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 927: three equal parts]]></title>
    <url>%2F2018%2F12%2F13%2F2018-12-13-LeetCode-problem-927%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/three-equal-parts/ 题意给一个仅包含0和1的数组A(3&lt;= A.length &lt;= 30000)，将数组分为三块，要求分为三块后的各自块二进制数保证相等，并给出如何分为三块的两个分割点，数组构成数字时可以接受前导0。 举例： [1, 1, 0] 代表 6 题目类型智力 题目分析挺有意思的题目。 首先不难想到如果要能分为三块那三个块中的1的个数必须相同，否则不可能分出三个相等的块来（同时特判一下数组全是0的情况）； 然后再将含有1的部分等分为三块以后，如何划分数组剩下的0是问题所在。因为三个块的值都相同，所以我们可以从数组最右边的连续0的个数判断三个块形成的相同的数字的后缀0的个数，这样就能够圈定出每个块的范围了。 最后还要判断一下三个块去除前导0后能不能保证相等，如果能保证相等就是所求答案；如果不能保证也一定不会有解了 举个例子，寻找 [1, 0, 0, 1, 0, 1, 0] 的分块方案 首先找到三个1的位置，由最后一个块最后只有1个0将数组分为[1, 0]、[0, 1, 0]、[1, 0] 验证后发现相等，问题得解 时间复杂度$O(N)$ 源代码代码写的非常凌乱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); int i, sum3 = 0; for (i = 0; i &lt; n; i++) &#123; if (A[i] == 1) sum3++; &#125; vector&lt;int&gt;false_ans(2, -1); if(sum3 % 3 != 0) return false_ans; vector&lt;int&gt;ans; int back0; for (i = n - 1; i &gt;= 0; i--) if (A[i] == 1) break; back0 = n - 1 - i; if (back0 == n) &#123; ans.push_back(0); ans.push_back(2); return ans; &#125; vector&lt;int&gt;back1; int tmp = 0, j, k; for (i = 0; i &lt; n; i++) &#123; tmp += A[i]; if (tmp == sum3 / 3) &#123; tmp = 0; back1.push_back(i); &#125; &#125; for (i = 0; i &lt; 2; i++) &#123; for (j = back1[i] + 1; j &lt;= back1[i] + back0; j++) if (j &gt;= n || A[j] == 1) return false_ans; ans.push_back(back1[i] + back0); &#125; ans[1]++; for (i = 0; i &lt; n; i++) if (A[i] == 1) break; for (j = ans[0] + 1; j &lt; n; j++) if (A[j] == 1) break; for (k = ans[1]; k &lt; n; k++) if (A[k] == 1) break; if (!(ans[0] - i == ans[1] - 1 - j &amp;&amp; ans[0] - i == n - 1 - k)) return false_ans; tmp = ans[0] - i; for (int t = 0; t &lt; tmp; t++) if (!(A[t + i] == A[t + j] &amp;&amp; A[t + i] == A[t + k])) return false_ans; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>智力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 930: binary subarrays with sum]]></title>
    <url>%2F2018%2F12%2F13%2F2018-12-13-LeetCode-problem-930%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/binary-subarrays-with-sum/ 题意给一个仅包含0和1的数组A(A.length &lt;= 30000)，求非空的和为S(0 &lt;= S &lt;= A.length)的子数组序列个数。 题目类型智力 题目分析不算很难的题目，写出来主要是因为最开始用的是滑动窗口过于麻烦，后面才发现部分和两下就解决了，警醒一下。 解的时候遍历数组A同时求一下部分和cur += A[i]，以当前位置为子区间右端点的满足部分和为S的数目就是部分和为cur - S的端点的数目和，用个f数组存一下数目就好了。 注意一下因为这样得到的区间数目左侧是开区间，所以开头要来个f[0] = 1。 时间复杂度$O(N)$ 源代码1234567891011121314151617class Solution &#123;public: int numSubarraysWithSum(vector&lt;int&gt;&amp; A, int S) &#123; int n = A.size(); int f[30020]; int cur = 0, ans = 0; memset(f, 0, sizeof(f)); f[0] = 1; for(int i = 0; i &lt; n; i++) &#123; cur += A[i]; if (cur - S &gt;= 0) ans += f[cur - S]; f[cur] += 1; &#125; return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>智力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 932: beautiful array]]></title>
    <url>%2F2018%2F12%2F12%2F2018-12-12-LeetCode-problem-932%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/beautiful-array/ 题意给定一个数字N &lt;= 1000, 构造一个 1 - N 的排列并保证: 对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * 2 = A[i] + A[j]。 题目类型构造 题目分析构造答案时可以把奇数全部放在左边偶数全部放在右边，奇数和偶数相加为奇数，这样就只可能奇数与奇数间，偶数与偶数间发生矛盾。 从而想到要保证分出后的奇数数组和偶数数组也要分别为相应的答案(漂亮数组)。因此使用递归的方法可以解决该问题。 例如对于 N = 5, 则要得到 N = 3 和 N = 2 的漂亮数组, 分别为 {1, 3, 2} 和 {1, 2}, 奇数部分乘以二减去一，偶数部分直接乘以二，即可得到 {1, 5, 3, 2, 4}，构造完成。 针对递归过程还可以做些优化，没有写。 时间复杂度$O(N ^ 2)$ 源代码1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; beautifulArray(int N) &#123; vector&lt;int&gt;ans; if (N == 0) return &#123;&#125;; if (N == 1) &#123; ans.push_back(1); return ans; &#125; if (N == 2) &#123; ans.push_back(1); ans.push_back(2); return ans; &#125; int mid = (N + 1) / 2; vector&lt;int&gt;lef,rig; lef = beautifulArray(mid); rig = beautifulArray(N - mid); for (int i = 0; i &lt; mid; i++) ans.push_back(lef[i] * 2 - 1); for (int i = 0; i &lt; N - mid; i++) ans.push_back(rig[i] * 2); return ans; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 956: tallest billboard]]></title>
    <url>%2F2018%2F12%2F10%2F2018-12-10-LeetCode-problem-956%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode.com/problems/tallest-billboard/ 题意给至多20个数字，数字之和&lt;=5000，在其中找到两个不相交的子集保证两子集分别的和相等，同时使得这个和值尽可能大。 题目类型动态规划 题目分析定义动态规划数组f[i][j]表示前i个数字中求和为j时所取得的最大和值，将问题转换为一个背包问题。背包的转移分为三种:把该数作为集合1的值，集合2的值和不加入该数。由此得到三个转移方程: f[i+1][j+rod[i]] = max(f[i+1][j+rods[i]], f[i][j]+rods[i]) f[i+1][j-rods[i]] = max(f[i+1][j-rods[i]], f[i][j]) f[i+1][j] = max(f[i+1][j],f[i][j]) 其中只有在把数字放进集合1的时候才统计其对最大和值的影响；同时为了防止数组和值为负值的时候越界给0加上了5000的偏移量。 时间复杂度$O(20*10000)$ 源代码123456789101112131415161718192021class Solution &#123;public: int f[22][10020]; int tallestBillboard(vector&lt;int&gt;&amp; rods) &#123; memset(f, -1, sizeof(f)); f[0][5000] = 0; int n = rods.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= 10000; j++) &#123; if (f[i][j] != -1) &#123; if (j + rods[i] &lt;= 10000) f[i + 1][j + rods[i]] = max(f[i + 1][j + rods[i]], f[i][j] + rods[i]); if (j - rods[i] &gt;= 0) f[i + 1][j - rods[i]] = max(f[i + 1][j - rods[i]], f[i][j]); f[i + 1][j] = max(f[i + 1][j], f[i][j]); &#125; &#125; &#125; return f[n][5000] == -1 ? 0 : f[n][5000]; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Chauncy Blog]]></title>
    <url>%2F2018%2F12%2F07%2F2018-12-07-hello-blog%2F</url>
    <content type="text"><![CDATA[“Let it be. ” 前言Chauncy 的 Blog 终于开通了。 跳过废话，直接看遇到的坑 一转眼时间就已经来到了8102年了，上次开博客已经是很久很久以前了，那个时候博客还是在博客园上，可惜当时虽然开了好头却没能坚持下来，到最后更新的篇数也是寥寥无几。前一阵想起来回过头来找一找以前的博客，却发现已经连用户名都已回忆不起来了。 想做这个博客也是想了很久的事情。 一来想要沉下心来做点事情，之前的动手查资料获取信息的能力实在是太烂，想起来做点什么总是遇到一堆怪七八糟的问题然后也不知道如何解决。在github开博的事情很早就想做，但是却因为jekyll老是有问题没弄成功过，这一问题经过这个暑假终于有所好转； 二来是发现以前老师和前辈说的话实在是有道理，人的记忆具有很强的时间效应。有的代码有的东西写的时候还挺清楚的，过一段时间再看又要花不少时间来回忆。写博客一来可以起到巩固知识二来可以备忘，于是决定做起来。 立个flag，这次要好好写下去。 正文接下来说说搭建这个博客的遇到的一些小问题。 这个博客主要的实现主题通通来自于hux前辈的博客和主题，因为本人的前端水平实在是有限，所以博客也基本就是套了huxblog-boilerplate，再改了一点自己的东西。在这里非常感谢前辈无私的分享。大部分的内容跟着里面的readme做就能做出来，这里也只说一点自己遇到的问题和小坑。 安装jekyll前先要安装Ruby + Devkit,版本要选高一点的，老版本的可能装不了jekyll。然后就是Windows安装Ruby的时候一定要按照默认安装目录安装。我装Ruby的时候装到了自己定的目录下面然后gem install bundle是可以的，但jekyll就报奇奇怪怪的错误，Google了一阵也没有弄明白，以为是版本号的问题费了不少事情。 个人将boilerplate的代码_layout目录下的keynote.html、page.html等文件里面的: `{% site.duoshuo_share && site.duoshuo_username %}`改为`{% site.duoshuo_share and site.duoshuo_username %}` `{% tag[1].size > {{site.featured-condition-size}} %}`改为`{% tag[1].size > site.featured-condition-size %}`没有修改之前会报警告。 P.S.:其实多说已经凉了这段删掉也无妨。 本地写好文件想通过jekyll s跑起来的时候发现端口占用，原因是jekyll网站跑起来后默认使用127.0.0.1的4000端口，而福昕阅读器的服务也会占用这一端口，解决方案是要不关掉福昕阅读器的服务要不通过jekyll s --port 端口号让网站跑在其它端口上，个人更倾向于第二种解决方法。 要在markdown中引用liquid代码时一定要用liquid中的 raw 代码块进行标注。否则jekyll渲染时会把liquid代码当作是正常代码来渲染。 最后再唠叨一点关于jekyll的理解吧： _includes 主要存放网页的 head, feet部分 _layouts 主要定义网页的排版等等 _posts 文章存放部分，写好的博客markdown文件都在这里 _site 本地运行jekyll s后会生成的网页文件夹 后记回顾这个博客的诞生，纯粹是出于个人兴趣。感谢无私地在网上分享知识的人们，提供模板的hux前辈，GitHub Pages以及Jekyll，没有他们的分享就不会有这个blog，也希望有朝一日这个blog的内容也可以帮助到其他的人。 人生如逆旅 我亦是行人 ---苏轼 后后记博客已经移到hexo next了，next真香hhh]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
